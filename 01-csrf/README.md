
# Preventing Cross Request Forgery (CSRF) Attacks

> In this article, you will learn about how Cross-Site Request Forgery attacks occur.

## Cross-Site Request Forgery

Cross-Site Request Forgery (CSRF) is a common class of vulnerability that tricks a user into submitting a web request on behalf of an attacker.

In many cases of CSRF, a malicious actor crafts a URL embedded with a request like so:

```
http://bank.com/send?recipient=Stranger&amount=2000
```

and uses clever tricks like link shortening or embedding it into a phishing email to get an authenticated user to click on it! In this example, a user who has an active session with the bank could click on it. The bank will carry out the transaction because the request is being made from that user’s browser! The attacker has hijacked the session and carried out a CSRF attack.

Let’s look at another example.

Suppose our web application allows users to change their password via the following link, where [USER PASSWORD] would contain the new desired password.

```
https://oursite.com/changepassword.php?new_password=[USER PASSWORD]
```

If the developers didn’t consider the impact of Cross-Site Request Forgery attacks, a threat actor may be able to create a new password link and send it to the user. When the user opens the link, they would initiate the password change, but with the attacker-supplied password! This would allow a hacker to take over their account!

Because the request considers nothing but the current session, a user would have their password changed.

CSRF attacks tend to target the web requests that are state-changing rather than requests that expect meaningful response data. State-changing requests could be: payment for a product, changing account information, transferring funds, changing security settings, and so on. These attacks could be highly detrimental to the victim user, which in turn could also worsen the reputation of the company behind a web application.

## Preventing CSRF

CSRF attacks are relatively easy to mitigate.

One of the simplest ways to prevent these attacks is to add a CSRF token. This token is a unique value that is added to each request. This value is dynamically generated by the server and used to verify all requests. This token is kept strictly with the form the user is currently on if they were making the legitimate request, so the attacker does not have access to it, and cannot get the user to complete the same request without the token.

Since this value is unique for every request and constantly changing, it is nearly impossible for an attacker to pre-create the URLs/requests for an attack AND bypass the token check.

While a CSRF token can prevent many malicious requests, it can still fail. If an application is vulnerable to Cross-Site Scripting (XSS) attack, a hacker could use their XSS attack to extract this token!

As an extra layer of security, we can ask users to re-authenticate by manually enter additional information prior to a critical request. For example, prior to changing a username, email, or password, we may want the user to enter their current password. By ensuring the request has the correct password, we can ensure that an attacker isn’t able to easily compromise a user, even with XSS.

## Conclusion

Cross-Site Request Forgery (CSRF) attacks are among the most common attacks on the web, affecting applications that carry out sensitive user requests. Through careful control of sessions and regular testing, we can prevent them!
